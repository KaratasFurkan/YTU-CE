#+TITLE: YTU CE
#+SETUPFILE: theme-readtheorg.setup
#+OPTIONS: num:nil
#+OPTIONS: \n:t
#+AUTHOR: Furkan Karataş
* Veri Yapıları
** 1. Ders

Not dağılımı: (2 vize + 2 ödev + Proje + 4 lab) = %60, final = %40

Soru: Verilen bir n sayısı için 1'den n'e kadar olan asal sayıları bulan
algoritmayı tasarlayın.

C kodu: ([[https://github.com/haliluluoglu/YTU-CE/blob/C-Language/Veri%20Yap%C4%B1lar%C4%B1%20ve%20Algoritmalar%C4%B1/primeNumber.c][Halil İbrahim Uluoğlu]])
#+begin_src C
  #include <stdio.h>
  #include <math.h>
  #include <stdlib.h>

  void main()
  {
    int number,i,j,number2;
    int *array;

    printf("Enter a number, please: ");
    scanf("%d", &number);

    array=(int *)malloc(sizeof(int)*(number+1));
    for(i=1; i<=number; i+=2)
      {
        array[i]=0;
      }
    array[2]=0;
    for(i=4; i<=number; i+=2)
      {
        array[i]=1;
      }
    number2=(int)sqrt(number);
    printf("%d\n", number2);
    for(i=3; i<=number2; i+=2)
      {
        if(array[i]==0)
          {
            printf("%d\n", i);
            for(j=(i*i); i<=number; j+=i)
              {
                array[j]=1;

              }
          }
      }
    printf("1 and 2 is prime number.\n");
    for(i=3; i<number; i+=2)
      {
        if(array[i]==0)
          {
            printf("%d is prime number.\n", i);
          }
      }
  }
#+end_src

* Hesaplama Kuramı
** 1. Ders

Not dağılımı: 1. vize %20 2. vize %20 ödevler %20 final %40
Devamsızlık hakkı: 12 saat ~ 4 hafta
Kitap: [[https://theswissbay.ch/pdf/Book/Introduction%2520to%2520the%2520theory%2520of%2520computation_third%2520edition%2520-%2520Michael%2520Sipser.pdf][Michael Sipser, Introduction To The Theory Of Computation 3rd Edition]]

İspat yöntemlerinden "Pidgeon Principle" çıkarmış.
* Bilgisayar Donanımı
** 1. Ders
* Yarı iletken Fiziği
** 1. Ders
* Mobil Programlamaya Giriş
** 1. Ders
[[https://docs.google.com/viewer?url=https%253A%252F%252Fwww.ce.yildiz.edu.tr%252Fpersonal%252Famacg%252Ffile%252F34465%252F18_19_Syllabus_MPG.pdf][Syllabus]]

*** 2018 Trendleri:
- Augmented Reality and Virtual Reality
- Mobile Payment
- Blockchain
- Security \rightarrow Malware \rightarrow Sandbox (malware bulmaya yarayan sanal makine)
- Wearable apps
- Instant apps
- IoT
- Cloud Based apps
- Beacon and Location-Based Services
- Chatbots
- AI
- Personalization
- Design Approach
- Cross Platform tools
** 2. Ders (yazan: Bilal Güvenç)
*** Pervasive Computing (Ubiquitous Computing)
- Ubiquitous Computing is a concept in software engineering and computer science where computing is made to appear everwhere and anywhere.
- In constrast to desktop computing, ubiquitous computing can occur using any device, in any location and in any format.

*** Mobile Computing
Mobile computing is a technology that allows transmission of data, voice and
video via a computer or any other wireless enabled device without having to be
connected to a fixed physical link.

1. Mobile Hardware
2. Mobile Software
	- Operating Systems
	- Applications
	- Security Malware
3. Mobile Communication
	- Global System for Mobile Communication (GSM)
	- (SMS)
	- Global Positioning System (GPS)
	- Internet
	- WiFi
	- Bluetooth
	- Radio

Feature Phone -> Personal Digital Assistan (PDA) -> Smartphone -> Mobile OS -> Tablet -> Wearable Tech -> Internet of Things (IoT)

*** Computer - Computer Communication
File Transfer Protocol FTP, TCP, MQTT, Qualm vs.

Human to Computer Communication
- Touch Screen
- Touch Pad
- Keyboard
- Mouse
- Microphone
- Stylus Pen
- Camera - Motion Capture
- Fingerprint

Computer to Human Communication
- Speakers
- Monitors (Screens)
- LED Lights
- Vibration

In-Site Processing
On-P… Processing
	
*** Research Topics Related to Ubiquitous Computing
- Distributed Computing
- Mobile Computing
- Location Computing
- Mobile Networking
- Context-Aware Computing
- Sensor Networks
- Internet of Things
- Human-Computer Interaction
- Artificial Intelligence

Ambient Intelligence
In computing, artificial intelligence refers to electronic enviroments that are
sensitive and responsive to the presence of people.
- Embedded (Gömülü)
- Personalized (Kişiselleştirilebilir)
- Adaptive (Adapte olan)
- Anticipatery (Algılayıp adapte olan)
- Context-Awareness

Non-Intrusive
Intrusive

*** Mobile Applications
A mobile app is a computere program designed to run on smartphones, tablets,
tablet pc's and other mobile devices.

Simulation vs Emulation
A simulation is a system that behaves similar something else, but is implemented
in an entirely different way. It provides the basic behaviours of a system but
may not necessarily abide all of the rules of the system beign simulated. It is
there to give you an idea about how something works.

| Emulators                                   | Simulators                      |
|---------------------------------------------+---------------------------------|
| Written in machine-level assembly languages | Written in high-level languages |
| More suitable for debugging                 | Difficult for debugging purpose |
| Complete re-implementation                  | Partial re-implementation       |

Mobile Application Development Constraints
- Limited Battery Life
- Limited Hardware
	- CPU
	- Memory
	- Storage
- Responsiveness
- Security and Privacy
- Range, Bandwidth & Quota
- Simplicity & User Friendly 
- Transmission Interference
	- Downloading
	- Uploading
	- Streaming
- Potential Hazards

** 3. Ders
*** Mobile Development Techniques
- Native Development (SDK, NDK, Specific Hardware, Software)
- Cross-Platform Development (JS, Dart, C#, Qt, HTML, CSS...)
- Mobile Web Development (Browser, HTML, CSS, JS)
- Hybrid App Development (HTML, CSS, JS, Webkit, Native Container)

| Decision Criteria          | Native                                  | Mobile Web         | Cross-Platform                                     |
|----------------------------+-----------------------------------------+--------------------+----------------------------------------------------|
| Quality of user experience | Excellent                               | Very Good          | Not as good as Native                              |
| Quality of apps            | High                                    | Medium             | Medium to low                                      |
| Potential users            | Limited to a particular mobile platform | Maximum            | Large as it reaches to users of different platform |
| App development cost       | High                                    | Low                | Medium to low                                      |
| Security of app            | Excellent                               | Depends on browser | Not good                                           |
| Supportability             | Complex                                 | Simple             | Medium to complex                                  |
| Ease of updating           | Complex                                 | Simple             | Medium to complex                                  |
| Time-to-market             | High                                    | Medium             | Short                                              |

*** Requirements of a Cross-Platform framework
- Multiple mobile platform support
- Built-in features
- Plugin supportability
- Security
- Power Consumption
  - Resource management (Memory, Storage, Cpu)
- Open source
- Backend Communication
- Rich user interface
* Yöneylem Araştırması
** 1. Ders
* Satış Yönetimi (Seçmeli 3)
** 1. Ders
Satış
- Müşteri noktasında satış
- Satışçı

Satışlar
- Küçük satışlar
- Büyük satışlar
- Stratejik satışlar

Pazarlama
Bireysel ve örgütsel amaçlara ulaşmak üzere değişime konu olacak malların,
hizmetlerin, fikirlerin, çözümlerin(ürün) geliştirilmesi, fiyatlandırılması,
dağıtırlması ve tutundurulması ile ilgili planlama ve uygulama sürecidir.
* Yapısal Programlama
** Ders Bilgisi
*** Dersin İçeriği

C Programlama Dilinde Veri Tipleri ; Kontrol Deyimleri ; Döngüler ; Diziler ve İşaretçiler ;
Çok Boyutlu Diziler ; İşaretçi Dizileri ; Karakter Dizileri ; Dinamik Bellek Yönetimi ;
Fonksiyonlar ; Fonksiyon İşaretçileri ; Özyinelemeli Fonksiyonlar ; Yerel ve Global Değişkenler ;
Yapılar ; Bitsel İşlemler ; Dosya İşlemleri ; C Önişlemcileri ; Makrolar ; C için Veri Yapıları ;
Linkli Listeler ; Statik ve Dinamik Kütüphaneler.

*** Haftalık Konular ve İlgili Ön Hazırlık Çalışmaları

| Hafta | Konular                                                                                        |
|-------+------------------------------------------------------------------------------------------------|
| <c>   | <l>                                                                                            |
| 1     | C Programlama Dilinde Veri Tipleri / Kontrol Deyimleri / Döngüler                              |
| 2     | Diziler / İşaretçiler / İşaretçiler Aritmetiği                                                 |
| 3     | Çok Boyutlu Diziler / İşaretçi Dizileri / Karakter Dizileri / İşaretçilerin İşaretçisi	 |
| 4     | Dinamik Bellek Yönetimi ve Fonksiyonlar                                                        |
| 5     | Fonksiyon İşaretçileri / Özyinelemeli Fonksiyonlar                                             |
| 6     | Yerel ve Global Değişkenler / Depolayıcı Sınıflar                                              |
| 7     | Yapılar / Birlikler / Bitsel İşlemler                                                          |
| 8     | Temel Dosya İşlemleri                                                                          |
| 9     | Ara Sınav 1                                                                                    |
| 10    | İleri Dosya İşlemleri                                                                          |
| 11    | C Önişlemcileri ve Makrolar                                                                    |
| 12    | Linkli Listeler                                                                                |
| 13    | Ara Sınav 2                                                                                    |
| 14    | Statik ve Dinamik Kütüphaneler                                                                 |
| 15    | Final                                                                                          |

** Genel Bilgiler

printf() ve scanf() fonksiyonlarında kullanılan veri tipi sembolleri

| Sembol | Veri Tipi             |
|--------+-----------------------|
| %c     | char                  |
| %d     | integer               |
| %s     | string                |
| %ld    | long integer          |
| %u     | unsigned integer      |
| %lu    | unsigned long integer |
| %f     | float                 |
| %lf    | double                |
| %x     | hexadecimal           |
| %p     | address               |

Bit manipulation operators

| Operator           | Symbol | Form      | Result                    |
|--------------------+--------+-----------+---------------------------|
| right shift        | >>     | x >> y    | x shifted right by y bits |
| left shift         | <<     | x << y    | x shifted left by y bits  |
| bitwise AND        | &      | x & y     | x bitwise ANDed with y    |
| bitwise OR         | \vert  | x \vert y | x bitwise ORed with y     |
| bitwise XOR        | ^      | x ^ y     | x bitwise XORed with y    |
| bitwise complement | ~      | ~x        | bitwise complement of x   |

** Pointerlar
*** Pointer oluşturma
**** Birinci dereceden pointer

Diziler, stringler(char dizisi) veya tek elemanlar için kullanılır.

#+BEGIN_SRC C
  void main(){
  int *p; //rastgele adres atanır, if(p) == if(non-zero) olur.
  int *p2 = NULL; //adresi 0 olur, null pointer denir, if(p) == if(zero) olur.
  char *char_p; // sizeof(*p) ve sizeof(*char_p) aynıdır. Adresin hafızada kapladığı
    // alan pointerın işaret ettiği veri tipinden bağımsızdır.
  double pi = 3.14;
  // pi değişkenine pointer atamak için 2 yol:
  double *dp = &pi; 

  double *dp2;
  ,*dp2 = pi;  // dp2 = &pi de olur.

  int dizi[5] = {1,2,3,4,5};
  p = dizi; // p = dizi[0] da olur.
  printf("%d, %d", *p, *(p + 1)); //çıktısı: 1, 2
  ,*p++;   // işaret edilen sayıyı değil adresi arttırır.
  ,*(p++); // sayıyı arttırır.
  }
#+END_SRC

Pointerlar için [[Dynamic][dinamik olarak hafıza açma]]


#+BEGIN_SRC C
#include <stdio.h>
#include <stdlib.h> //malloc, calloc gibi fonksiyonlar bu kütüphanede.

void main(){
int *p = NULL, elemanSayisi = 5;
p = (int *) malloc(elemanSayisi * sizeof(int));
p = malloc(elemanSayisi * sizeof *p) // böyle yapmak daha makbulmüş. Yani cast yapmamak ve
                                     // sizeof(int) yerine sizeof *p kullanmak. Evet parantezsiz kullanılıyor.

// Direk pointer oluştururken de yapılabilir:
char *cp = calloc(50, sizeof(char)); // char pointer icin calloc kullanmakta fayda var,
                                      // string alırken stringin sonunun null ile bitmesini sağlar.

}
#+END_SRC
**** <<Dynamic>>Dynamic memory allocation

Runtime sırasında hafıza açmaya yarar. Dynamic memory allocation fonksiyonlarını kullanabilmek için stdlib.h
kütüphanesi include edilmedilir.

| Function | Description                                                                              | Syntax                                 |
|----------+------------------------------------------------------------------------------------------+----------------------------------------|
| malloc   | allocates the specified number of bytes                                                  | p = malloc (number *sizeof(int));      |
| calloc   | allocates the specified number of bytes and initializes them to zero                     | p = calloc (number, sizeof(int));      |
| realloc  | increases or decreases the size of the specified block of memory, moving it if necessary | p = realloc (p, number * sizeof(int)); |
| free     | releases the specified block of memory back to the system                                | free(p);                               |

**** Double pointer

Matrisler ve string dizileri(char matrisi gibi de düşünülebilir. stringler 1 pointer geriden geliyor.) için kullanılır.

#+BEGIN_SRC C
void main(){
int **matrix = NULL;

}
#+END_SRC
** Function Pointers

Basit bir toplama fonksiyonu:

#+BEGIN_SRC C
  int topla (int a, int b){
      return a + b;
  }
#+END_SRC

Function pointer ile kullanımı:

#+BEGIN_SRC C
  #include <stdio.h>

  void main(){
      int (* functionPointer)(); // integer değer döndüren (return) bir fonksiyonu
				 // işaret eden pointer.
    //int (* functionPointer)(int, int); // böyle de yazılabilir.
    //int (* functionPointer)() = topla // initialization
      functionPointer = topla;
    //functionPointer = &topla; // böyle de yazılabilir.
      int sum;
      sum = (* functionPointer)(5, 10);
    //sum = functionPointer(5, 10); // böyle de yazılabilir. hoca üstteki iyi dedi.
      printf("%d", sum); // result 15
      return 0;
  }
#+END_SRC

Not: İşaret edilecek fonksiyonun dönüş tipi ile pointerın tipi uyuşmalı. int topla(int a, int, b) fonksiyonunu char (* fp)(); ile point edemiyoruz.

** Vize

#+BEGIN_SRC C
void myStrcpyV3(char *str1,char *str2)
{
	while(*str2++=*str1++);	//An assignment expression has the value of the left operand after the assignment
	
}
#+END_SRC

#+BEGIN_SRC C
typedef struct{
 char OGR_isim[15] , OGR_soyisim[20]; 
 short OGR_yas;
 float OGR_puan; 
}OGR; // ogr tipi oluþturulur. bu tipden yeni degiskenler uretilebilir
#+END_SRC

#+BEGIN_SRC C
#include <stdio.h>
#include <stdlib.h>
/*
typedef struct{
 char gun;
 char ay;
 char yil;	
} TARIH;	//typedef ile tanimlandigi icin tarih tipi baska structure lar icinde de kullanilabilir

typedef struct{
 char isim[30];
 int maas; 
 TARIH tarih;
}CALISAN; 
*/

/*
vtypedef struct {
 char isim[30];
 int maas; 
 struct {
 	char gun;
 	char ay;
 	char yil;
 }tarih;		// sadece bir kez kullanilabilir
  
}CALISAN; 
*/


struct CALISAN{
 char isim[30];
 int maas; 
 struct {
 	char gun;
 	char ay;
 	char yil;
 }tarih;		// sadece bir kez kullanilabilir
}; 


/*  ILLEGAL KULLANIM (tarih struct'indan bir deðiþken uretilmeli)
struct CALISAN{
 char isim[30];
 int maas; 
 struct tarih{
 	char gun;
 	char ay;
 	char yil;
 };		// sadece bir kez kullanilabilir
};
*/

int main()
{
	//CALISAN calisan2={"ali",7000,{11,10,90}}; //typedef ile tanimlanmissa
	//CALISAN calisan1;							//typedef ile tanimlanmissa
	struct CALISAN calisan1;
	calisan1.tarih.ay=2;
	calisan1.tarih.gun=12;
	calisan1.tarih.yil=98;
	return 0;
}


#+END_SRC

#+BEGIN_SRC C
# include <stdio.h>
# include <stdlib.h>
int main()
{
	int sum,sub;
	int addInt(int, int);
	int subInt(int, int);
    /*int (**foo_ptr_array)();
    foo_ptr_array = calloc( 2, sizeof( int (*)() ) );*/
	
	/* or */
	int (**foo_ptr_array)() = (int (**)())calloc( 2, sizeof( int (*)() ) );
	
	/* or */
	/* int (*foo_ptr_array[2])();  
	*/
	
	foo_ptr_array[0] = addInt;
	foo_ptr_array[1] = subInt;
	sum=(*foo_ptr_array[0])( 1,2 );
	sub=foo_ptr_array[1]( 1,2 );
	
	printf("sum:%d sub:%d\n",sum,sub);
}

int addInt(int n, int m) {
    return n+m;
}

int subInt(int n, int m) {
    return n-m;
}



#+END_SRC

#+BEGIN_SRC C
/*16 soruluk yes/no testi yapýlýyor */
/* cevap anahtarýný y/n þekline al 16bitlik answers'da tut */
/* short olarak kiþinin verdiði cevabý al*/
/* kaç soru bildiðini short olarak yaz*/
#include <stdio.h>
int main()
{ 
	unsigned short correctanswers = 0,answer2=0,testanswer,result; 
	short int j,score=0; 
	char c; 
	printf("sizeof short %d\n",sizeof(j));
	/* eger ilk soru en sol bitte tutuluyorsa*/
	/*for (j=0; j <= 15; j++)
	{ 
		scanf ("%c", &c); 
		if (c == 'y' || c == 'Y') 
		{
			answer2=1<<(15-j);
			correctanswers = answer2 | correctanswers;
			answer2=0;
		}
	}
	*/
	/* eger ilk soru en sað bitte tutuluyorsa*/
	answer2=1;
	for (j=0; j <= 15; j++)
	{ 
		c=getch();
		putch(c);
		if (c == 'y' || c == 'Y') 
			correctanswers = answer2 | correctanswers;
		answer2<<=1;
	}
	
	
	printf( "Correct answers :%d\n",correctanswers);
	printf("Kullanýcýnýn verdiði cevaplar?\n");
	scanf("%d",&testanswer);
	result=testanswer^correctanswers;  //aynýysa 0 farklýysa 1
	printf("result:%d",result);
	answer2=1;
	for (j=0; j <= 15; j++)
	{ 
		if (answer2&result)
			score++;
		answer2=answer2<<1;
	}
	printf("score:%d\n",16-score);
	
}

#+END_SRC

LİNKED LİST
#+BEGIN_SRC C
#include <stdio.h>
#include <stdlib.h>

struct node{
    int val;
    struct node *next;
};

void push(struct node *, int);
struct node *pushFront(struct node *, int);
void list(struct node *);
void deleteNode(struct node *, int);

int main()
{
	struct node *head, *newHead, *dummy;
	int num;
	head = malloc(sizeof(struct node));
	if (head == NULL) {
    	return 0;
	}	
	
	printf("listenin sonuna eklenmek uzere eleman veriniz\n");
    scanf("%d",&num);
	head->val = num;
	head->next = NULL;
	
	printf("listenin sonuna eklenmek uzere eleman veriniz\n");
    scanf("%d",&num);
	push(head,num);
	
	printf("listenin sonuna eklenmek uzere eleman veriniz\n");
    scanf("%d",&num);
	push(head,num);
	
	printf("listenin sonuna eklenmek uzere eleman veriniz\n");
    scanf("%d",&num);
	push(head,num);
	
	list(head);
	
	printf("listenin basina eklenmek uzere eleman veriniz\n");
    scanf("%d",&num);
	newHead=pushFront(head,num);
	list(newHead);
	
	printf("listeden silinecek elemani veriniz\n");
	scanf("%d",&num);
	if (num==newHead->val)
	{
		dummy=newHead->next;
		free(newHead);
		newHead=dummy;
	}
	else
		deleteNode(newHead,num);
	list(newHead);
	
	
	return 0;

}

// listenin sonuna node ekler
void push(struct node *head, int val) {
    struct node* current = head;
    while (current->next != NULL) {
        current = current->next;
    }

    current->next = malloc(sizeof(struct node));  	
    current->next->val = val;					
    current->next->next = NULL;					
}

// elemanlarý listeler
void list(struct node *head)
{
	struct node* current = head;
    printf("liste elemanlari:\n");
	while (current->next != NULL) {
    	printf("-%d-",current->val);
        current = current->next;
    }
    printf("-%d-\n",current->val);
}

// listenin baþýna node ekler
struct node* pushFront(struct node *head, int val) {
    struct node* newN;
	newN=malloc(sizeof(struct node)); 
	newN->next =head;
	newN->val =val;
    return newN;
}

// elemanlarý listeler
void deleteNode(struct node *head, int val)
{
	struct node* current = head, *before=NULL;
    
    while ((current->val != val)&&(current->next != NULL))
	{
	    before=current;
		current = current->next;
	}
    
    if (current->next == NULL)
    	printf("silinmek istenen eleman listede yok\n");
    else
    {
    	before->next=current->next;
    	free (current);
	}
        
}


#+END_SRC

lab:

#+BEGIN_SRC C
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
 
typedef struct point {
   int x,y;
}POINT ;
void WRITE(POINT *p,int N);
void SORT(POINT *p,int N,int (*compare)( int a, int b ));

int ascending( int a, int b ){
   return b < a;   /* swap if b is less than a */
}

int descending( int a, int b ){
   return b > a;   /* swap if b is greater than a */
}
 
void main() {
   srand(time(NULL));
   int N;
   int i, j;
   int order;
   printf("Enter N:"); scanf("%d",&N);
   POINT *p=(POINT*)malloc(N*sizeof(POINT));
   printf( "Enter 1 to sort in ascending order,\n"
           "Enter 2 to sort in descending order: " );
   scanf("%d",  &order );
   
   for (i = 0; i < N; i++) {
	    (p+i)->x=rand()%9+1;
	    (p+i)->y=rand()%9+1;
   }
   printf("BEFORE\n");
   WRITE(p,N); 
   printf("AFTER\n");  
   if ( order == 1 ) {
      SORT( p, N, ascending );
   }
   else { /* pass function descending */
      SORT( p, N, descending );
   }
   
   WRITE(p,N);
   getch();
}

void WRITE(POINT *p,int N){
	int i=0;	
	printf("X - Y \n");
	printf("------\n");
	for (i = 0; i < N; i++) 
		printf("%d - %d \n",(p+i)->x,(p+i)->y);
}

void SORT(POINT *p,int N,int (*compare)( int a, int b )){
	int i=0, j=0;
	int X=0,Y=0;
	POINT temp;
	for (i = 1; i < N; i++)
      for (j = 0; j < N - i; j++) {
         X=pow(p[j].x,2)+pow(p[j].y,2);
         Y=pow(p[j+1].x,2)+pow(p[j+1].y,2);
		 if ((*compare)( X,Y )) {
            temp = p[j];
            p[j] = p[j+1];
            p[j+1] = temp;
         }
      } 
}

#+END_SRC

* Alt Seviye Programlama
** Ders Bilgisi
*** Dersin İçeriği

Intel 80x86 Ailesi İşlemci Mimarisi; Yazmaçlar ve Görevleri; Bayraklar; Komutlar (Mnemonic);
Adresleme Kipleri; Sözde (Pseudo) Komutlar; EXE ve COM Tipi Programlar;
Yordam ve Yordam Çağırma, Makrolar, Kesim Birleştirme; Yordamlara Parametre Aktarımı;
Kesmeler; Yüksek Seviyeli Diller ile Bağlantılar.

*** Haftalık Konular ve İlgili Ön Hazırlık Çalışmaları

| Hafta | Konular                                                                                                                                |
|-------+----------------------------------------------------------------------------------------------------------------------------------------|
| <c>   | <l>                                                                                                                                    |
| 1     | Alt seviye dilinin özellikleri, sayı ve kodlama sistemleri, 80x86 ailesi işlemcileri, yazmaçları ve bayrakları ile kesim organizasyonu |
| 2     | Komutlar (veri aktarımı, aritmetik ve dallanma)                                                                                        |
| 3     | Komutlar (çevrim, bayraklar, mantıksal, öteleme, döndürme)                                                                             |
| 4     | Komutlar (katar işlemleri, ön ekler)                                                                                                   |
| 5     | Adresleme modları, alt seviye programlama araçları, sözde komutlar                                                                     |
| 6     | Çalışma ortamının hazırlanması ve debug kullanımı                                                                                      |
| 7     | EXE tipinde alt seviye programlama                                                                                                     |
| 8     | COM tipinde alt seviye programlama                                                                                                     |
| 9     | Ara Sınav 1                                                                                                                            |
| 10    | Yordam ve macro kullanımları                                                                                                           |
| 11    | Alt-programlar ve parametre aktarma yöntemleri                                                                                         |
| 12    | Ortak kesim kullanımı ve EXTRN/PUBLIC tanımlamaları                                                                                    |
| 13    | Ara Sınav 2                                                                                                                            |
| 14    | Kesme, vectör tablosu ve alt seviye programlama dilinin yüksek seviyeli diller ile birlikte kullanılması                               |
| 15    | Final                                                                                                                                  |

** Sayı Sistemleri
*** İki sayı düzeninde çıkarma

Onluk tabandaki gibi borç usulü yapılabilir veya çıkartılacak sayının 2'ye tümleyeni alınır, sayılar toplanır.

 01000011 (67)
\plus11101011 (-21)
=100101110 (46) (byte'ın en anlamlı biti 0 o.g sayı pozitif. En soldaki 1'i sallamıyoruz.)

 00010101 (21)
\plus01000011 (-67)
=11010010 (-46) (byte'ın en anlamlı biti 1 o.g sayı negatif. Sonucu bulmak için bir kere daha two's complement almalıyız.)

*** Octal ve Hexadecimal sayı düzeni

Octaldaki her basamak binaryde 3 bite, hexadecimaldeki her basamak binaryde 4 bite(1 nibble) karşılık geliyor.
1111b = Fh,  1010b = Ah
53FC8h = 0101 0011 1111 1100 1000b

** Registerlar

(16 bit - 2 byte - 1 word)

| AX | AH + AL | Accumulator Register | I/O işlemlerinde, aritmetik işlemlerde ve stringlerde kullanılır. Bazı komutlarda gizli operand durumundadır. Bazı durumlarda daha hızlı çalışır. |
| BX | BH + BL | Base Register        | Aritmetik işlemlerde ve dizilerde(index olarak) kullanılır. dizi[BX,SI,DI(sadece bunlar gelebilir)]                                               |
| CX | CH + CL | Count Register       | Döngülerde, shift işlemlerinde kullanılır.                                                                                                        |
| DX | DH + DL | Data Register        | I/O işlemlerinde, çarpma ve bölme işlemlerinde(çarpmada DX:AX, bölmede DX kalan AX bölüm) kullanılır.                                             |
| SP | -       | Stack Pointer        | Stackte işlem yapılacak alanı gösterir. Push ve pop ile değeri 2 artar veya azalır.                                                               |
| BP | -       | Base Pointer         | Stackte istediğimiz veriye ulaşmayı, okumayı ve kopyalamayı sağlar, stacki bozmaz.                                                                |
| IP | -       | Instruction Pointer  | İşlemcinin o anda çalıştıracağı komutun kod kesimi içindeki yerini belirtir.                                                                      |
| SI | -       | Source Index         | Göreli konumu göstermek için kullanılır.                                                                                                          |
| DI | -       | Destination Index    | SI gibi kullanılabiliyor, ayrıca ek kesim içindeki veriye erişmek için de kullanılır. Sanırım şöyle: SI = *p + 5 deki "*p" DI ise "+ 5"           |

** Bayraklar(Flags)

Set = 1
Clear/Reset = 0

| CF | Carry Flag          | Elde/ödünç durumlarında 1 olur.                                                                                                                                                                                                  |
| PF | Parity Flag         | İşlem sonucunda 1lerin sayısı çift ise(buna even parity deniyor) 1 olur. Odd parity durumunda 0 olur.                                                                                                                            |
| ZF | Zero Flag           | İşlem sonucu 0 ise ZF 1 olur.                                                                                                                                                                                                    |
| SF | Sign Flag           | İşlem sonucunda sayının en anlamlı biti 1 ise SF 1 olur.                                                                                                                                                                         |
| TF | Trap Flag           | Adım bayrağı. TF = 1 ise her komuttan sonra bir kesme üretilir, böylece programı takip edebiliriz.                                                                                                                               |
| IF | Interrupt Flag      | Kesmeye izin verilip verilmeyeceğini belirtir.                                                                                                                                                                                   |
| DF | Direction Flag      | String işlemlerinde işlemin yüksek adresli bellekten düşük adresli belleğe doğru yürütülebilmesi için DF 1 olmalıdır. Aksi halde işlem düşükten adresten yükseğe ilerler.                                                        |
| OF | Overflow Flag       | Aritmetik taşma(işaretli sayılarla yapılan işlemlerde işaretli sonucun tanımlı alana sığmaması) olması halinde OF 1 olur.                                                                                                        |
| AF | Auxilary Carry Flag | 8'li işlemlerde düşük anlamlı 4'lüden yüksek anlamlı 4'lüye elde/ödünç, 16'lı işlemlerde düşük anlamlı 8'liden yüksek anlamlı 8'liye elde ödünç aktarılması durumunu kullanıcıya belirtmek üzere AF bayrağının değeri 1 yapılır. |
** Gerçek Kipte Fiziksel Adres Hesabı

Fiziksel Adres = 16x Kesim Yazmaç Değeri(CS - SS - DS, ES) + İşaret Yazmaç Değeri(IP - SP, BP - SI, DI, BX)(Göreli konum)

Örnek: CS <-- 2C58h ve IP <-- 0013h olursa CS:IP ikilisi hangi fiziksel adresi belirler?
2C58h x16 = 2C580h (16 ile çarpmak = 4 bit(hexadecimalde 1 basamak) sola shift)
2C580h + 0013h = 2C593h (Toplama sonucunda 20 bitlik değer elde edilir.)

** Komutlar
*** Veri Aktarım Komutları

| Komutlar                               | Kullanımı                                    | Ek bilgi                                                                                                                                                                                  |
|----------------------------------------+----------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| *MOV* /move data/                      | MOV destination, source                      | Bayraklarda değişiklik yapmaz                                                                                                                                                             |
| *LEA* /load effective address/         | LEA SI, sayiA                                | SI sayiA'nın adresini alır.                                                                                                                                                               |
| *LDS* /load data segment register/     | LDS SI, 1000H                                | İşlem sonucunda SI 1001H(high) ve 1000H(low) adreslerindeki değeri alır. İşlemin arka planında da DS bir sonraki adresteki değeri alır (yine high + low).                                 |
| *LES* /load extra segment register/    | LES DI, 1000H                                | Üsttekinin aynısı, SI yerine DI, DS yerine ES.                                                                                                                                            |
| *XCHG* /exchange/                      | XCHG AX, sayiB                               | İki değişken arası swap yapmaz. Bir tanesi illaki register olacak. =XCHG AX, BX=, =XCHG BX, AX='ten daha hızlı ve daha az yer kaplıyor.                                                   |

*** Aritmetik Komutlar

| Komutlar                               | Kullanımı                                    | Ek bilgi                                                                                                                                                                                                                                                                                                                                                                                            |
|----------------------------------------+----------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| *ADD* /addition/                       | ADD sayi, 5                                  | --> sayi = sayi + 5. MOV AL,255; ADD AL,5 işlemleri sonrası carry flag 1 olur.                                                                                                                                                                                                                                                                                                                      |
| *ADC* /add with carry/                 | MOV AH, 0; MOV AL, 255; ADD AL, 5; ADC AH, 0 | --> AH = 0, AL = 255, AL += 5 (CF = 1 oldu), ADC AH,0 (AH = CF = 1 oldu) --> *AX = 0104H* (işlem sonunda CF tekrar 0 olur)                                                                                                                                                                                                                                                                          |
| *SUB* /subtraction/                    | SUB sayi, 5                                  | sayi = sayi - 5                                                                                                                                                                                                                                                                                                                                                                                     |
| *SBB* /subtraction with borrow/        | SBB sayi, 5                                  | sayi = sayi - 5 - CF                                                                                                                                                                                                                                                                                                                                                                                |
| *INC* /increment/                      | INC AX                                       | AX++. =INC AX; INC AX=, =ADD AX, 2='den daha az yer kaplıyor.                                                                                                                                                                                                                                                                                                                                       |
| *DEC* /decrement/                      | DEC sayi                                     | sayi- -.                                                                                                                                                                                                                                                                                                                                                                                            |
| *NEG* /negate / two's complement/      | NEG BX                                       | BX'in 2'ye tümleyenini alır. (C'de: =sayi = ~sayi + 1=)                                                                                                                                                                                                                                                                                                                                             |
| *MUL* /unsigned multiplication/        | MUL CL; 8 bit                                | AX \leftarrow AL * CL                                                                                                                                                                                                                                                                                                                                                                               |
|                                        | MUL BX; 16 bit                               | DX:AX \leftarrow AX * BX                                                                                                                                                                                                                                                                                                                                                                            |
| *IMUL* /integer signed multiplication/ | IMUL CL, sayi                                | MUL gibi tek operandlı veya opr1 \leftarrow opr2 * opr3 olacak şekilde üç operandlı da kullalılabiliyor.                                                                                                                                                                                                                                                                                            |
| *DIV* /unsigned divide/                | DIV BH                                       | AX / BH işlemi yapılır. AL \leftarrow bölüm, AH \leftarrow kalan olur.                                                                                                                                                                                                                                                                                                                              |
|                                        | DIV sayiWord                                 | DX:AX şeklinde tutulan 32 bit sayı /sayiWord/'e bölünür. AX \leftarrow bölüm, DX \leftarrow kalan olur.                                                                                                                                                                                                                                                                                             |
| *IDIV* /integer signed division/       | IDIV CH                                      | DIV'in işaretli olanı.                                                                                                                                                                                                                                                                                                                                                                              |
| *CMP* /compare/                        | CMP AX, BX                                   | AX - BX işlemi yapılır. Operandların değerini etkilemez. [[CMP][Karşılaştırmanın sonucu bayraklardaki değerlere göre belirlenir]]. CMP komutundan hemen sonra bir dallanma komutu kullanılmalıdır. Çok nadir durumlarda CMP ile dallanma komutu arasına başka komutlar girebilir fakat bu komutların bayrakların değerini değiştirmeyen türden (örneğin veri aktarım komutları) olmasına dikkat edilmelidir. |



<<CMP>>CMP kontrol tablosu:

| Condition | Signed Comparison       | Unsigned Comparison  |
|-----------+-------------------------+----------------------|
| a > b     | ZF = 0 \wedge SF = OF   | CF = 0 \wedge ZF = 0 |
| a \ge b   | SF = OF                 | CF = 0               |
| a = b     | ZF = 1                  | ZF = 1               |
| a \le b   | ZF = 1 \wedge SF \ne OF | CF = 1 \vee ZF = 1   |
| a < b     | SF \ne OF               | CF = 1               |

*** Dallanma Komutları

IP yazmacının değeri bu komutların çalışması ile değişir.

**** Koşullu Dallanma Komutları

Koşullu dallanma komutlarında atlama aralığı 8 bit ile sınırlıdır. 128 byte geri veya 127 byte ileri gidebilir.

***** Basit Koşullu Dallanma Komutları

| Komut                                            | Koşul                                                                      | Flag karşılığı |
|--------------------------------------------------+----------------------------------------------------------------------------+----------------|
| *JZ* / *JE* /jump zero / jump equal/             | CMP işleminin sonucunda eşitlik çıkması                                    | ZF = 1         |
| *JNZ* / *JNE* /jump not zero / jump not equal/   | CMP işleminin sonucunda eşitlik çıkmaması                                  | ZF = 0         |
| *JS* /jump if sign/                              | CMP işleminin sonucunda elde edilen değer negatif ise                      | SF = 1         |
| *JNS* /jump no sign/                             | CMP işleminin sonucunda elde edilen değer pozitif ise                      | SF = 0         |
| *JO* /jump if overflow/                          | CMP işleminin sonucunda aritmetik bir taşma var ise                        | OF = 1         |
| *JNO* /jump no overflow/                         | Taşma yoksa                                                                | OF = 0         |
| *JP* / *JPE* /jump on parity / jump parity even/ | CMP işleminin sonucunda even parity(1 sayısının çift sayıda olması) olması | PF = 1         |
| *JNP* / *JPO* /jump no parity / jump parity odd/ | Odd parity oluşması                                                        | PF = 0         |

***** İşaretsiz Sayı İşlemlerine Ait Koşullu Dallanma Komutları

| Komut                                                                      | Koşul                                     | Flag karşılığı       |
|----------------------------------------------------------------------------+-------------------------------------------+----------------------|
| *JB* / *JNAE* / *JC* /jump below / jump not above equal / jump carry/      | opr1 opr2'nin altında ise (= opr1 < opr2) | CF = 1               |
| *JA* / *JNBE* /jump above / jump not below equal/                          | opr1 opr2'nin üstünde ise (= opr1 > opr2) | CF = 0 \wedge ZF = 0 |
| *JAE* / *JNB* / *JNC* /jump above equal / jump not below / jump not carry/ | opr1 \ge opr2                             | CF = 0               |
| *JBE* / *JNA* /jump below equal / jump not above/                          | opr1 \le opr2                             | CF = 1 \vee ZF = 1   |

***** İşaretli Sayı İşlemlerine Ait Koşullu Dallanma Komutları

| Komut                                                  | Koşul         | Flag karşılığı                 |
|--------------------------------------------------------+---------------+--------------------------------|
| *JL* / *JNGE* /jump less / jump not greater and equal/ | opr1 < opr2   | SF \oplus OF = 1 \wedge ZF = 0 |
| *JNL* / *JGE* /jump not less / jump greater and equal/ | opr1 \ge opr2 | SF \oplus OF = 0               |
| *JLE* / *JNG* /jump less equal / jump not greater/     | opr1 \le opr2 | SF \oplus OF = 1 \wedge ZF = 1 |
| *JG* / *JNLE* /jump greater / jump not less equal/     | opr1 > opr2   | SF \oplus OF = 0 \wedge ZF = 0 |

**** Koşulsuz Dallanma Komutları

| Komut                    | Kullanım Şekli                | Ek Bilgi                |
|--------------------------+-------------------------------+-------------------------|
| *JMP* /near jump/        | JMP /label/                   | Kesim içi dallanma      |
| *JMP FAR PTR* /far jump/ | JMP FAR PTR /label/ / /adres/ | Kesimler arası dallanma |

*** Öteleme ve Döndürme Komutları

Eklenecek.

*** Mantıksal Komutlar

Eklenecek.

*** Stack Komutları

Eklenecek.

** Bazı kod bloklarının assemblydeki eşdeğerleri
*** If bloğu

C dilinde:
#+BEGIN_SRC C
  if (AX == 0) {
      BX = 2;
  }
  else{
      BX = 1;
  }
  CX = 5;
#+END_SRC

Assembly dilinde:
#+BEGIN_SRC asm
		  CMP AX,0
		  JZ thenblock
		  MOV BX,1	
		  JMP nextblock	
  thenblock:	MOV BX,2
  nextblock:	MOV CX,5
#+END_SRC
*** For bloğu

C dilinde:
#+BEGIN_SRC C
  AX = 0;
  for (i = 1; i <= 10; ++i) {
      AX += i;
  }
#+END_SRC

Assembly dilinde:
#+BEGIN_SRC asm
	  XOR AX, AX
          MOV CX, 10 //LOOP komutu otomatik olarak //
L1:	  ADD AX, CX //CX'in değerini 1 azaltır    //
	  LOOP L1
#+END_SRC

İkişer azaltma örneği:
#+BEGIN_SRC asm
	  XOR AX, AX
	  MOV CX, 10   // LOOP yerine CMP ve JMP
L1:	  ADD AX, CX   // kullanarak veya
	  DEC CX       // CX ve JCXZ kullanarak 
	  LOOP L1      // da yapılabilir.
#+END_SRC

*** While bloğu

C dilinde:
#+BEGIN_SRC C
  AX = 0;
  i = 1;

  while (i <= 10 ) {
      AX += i;
      i += 2;
  }
#+END_SRC

Assembly dilinde:
#+BEGIN_SRC asm
	  XOR AX, AX
	  MOV SI, 1
  L1:	CMP SI, 10     ////////////////////////////////////////////
	  JA next      // do while bloğu için once işlem         //
	  ADD AX, SI   // en son(next'ten once) CMP yapılabilir. //
	  ADD SI, 2    ////////////////////////////////////////////
	  JMP L1
  next:	
#+END_SRC

*** İç içe for

Bubble sort üzerinden örnek:

C dilinde:
#+BEGIN_SRC C
  for (i = 0; i <= 3; ++i) {
      for (j = i + 1; j <= 4; ++j) {
	  if (dizi[i] < dizi[j]) {
	      swap(&dizi[i], &dizi[j]);
	  }
      }
  }
#+END_SRC

Assembly dilinde:
#+BEGIN_SRC asm
	  MOV CX, 4
	  MOV SI, 0
  L2:	PUSH CX      // dıştaki for'un CX'ini stacke atıyoruz
	  MOV DI, SI   // push komutu registerın orjinal değerini değiştirmez.
  L1:	INC DI
	  MOV AX, dizi[SI]
	  CMP AX, dizi[DI]
	  JGE NEXT
	  XCHG AX, dizi[DI]
	  MOV dizi[SI], AX
  next:	LOOP L1
	  POP CX   // CX = Stack'teki en üstte bulunan değer (yani 3.
	  INC SI   // satırda attığımız CX değeri)
	  LOOP L2
#+END_SRC

*** 
* Ayrık Matematik
** Ders Bilgisi
*** Dersin İçeriği

Mantık;Kümeler ve Foksiyonlar; Algoritmanın Temelleri; Sayılar ve Matrisler; Hesaplama Teknikleri;
Kromatik Polinomlar; Graflar; Ağaçlar; Boole Cebri; Çıkışlı ve Çıkışsız Solu Durum Makineleri

*** Haftalık Konular ve İlgili Ön Hazırlık Çalışmaları

| Hafta | Konular                                     |
|-------+---------------------------------------------|
| <c>   | <l>                                         |
| 1     | Matematiğin Dili                            |
| 2     | Mantık, Kümeler ve Fonksiyonlar-I           |
| 3     | Mantık, Kümeler ve Fonksiyonlar-II          |
| 4     | Algoritmalar ve Algoritmaların Karmaşıklığı |
| 5     | Hesaplama Teknikleri                        |
| 6     | Bağıntılar                                  |
| 7     | Kromatik Polinomlar                         |
| 8     | Ağaçlar ve Uygulamaları-I                   |
| 9     | Ara Sınav 1                                 |
| 10    | Ağaçlar ve Uygulamaları-II                  |
| 11    | Graf Teori-I                                |
| 12    | Graf Teori-II                               |
| 13    | Ara Sınav 2                                 |
| 14    | Çıkışlı ve Çıkışsız Sonlu Durum Makineleri  |
| 15    | Final                                       |

* Lojik Devreler
** Ders Bilgisi
*** Dersin İçeriği

Sayı Sistemleri; Boole Cebri; Lojik Fonksiyonların İndirgenmesi; Karnaugh Haritaları;
Quine-McClusky Yöntemi; Kombinezonal Devre Analizi; Kombinezonal Devre Tasarımı;
Senkron ve Asenkron Devre Yapıları; Ardışıl Devre Analizi; Ardışıl Devre Tasarımı;
Saklayıcılar, Sayıcılar, Bellekler.

*** Haftalık Konular ve İlgili Ön Hazırlık Çalışmaları

| Hafta | Konular                                                                             |
|-------+-------------------------------------------------------------------------------------|
| <c>   | <l>                                                                                 |
| 1     | Sayısal sistemlerin genel özellikleri                                               |
| 2     | Boole cebrinin temelleri                                                            |
| 3     | Lojik fonksiyonlar, kanonik ve standart biçimler                                    |
| 4     | Lojik kapılar, lojik fonksiyonlarin sadeleştirilmesi                                |
| 5     | Karnaugh haritaları/diyagramları, Quine –McCluskey yöntemi                          |
| 6     | Kombinezonsal devreler, aritmetik toplama çıkarma devreleri, seçiciler, dağıtıcılar |
| 7     | Kod çözücüler, kodlayıcılar, ALU tasarımı, 7–parçalı gösterge                       |
| 8     | Ardışıl devre temelleri                                                             |
| 9     | Ara Sınav 1                                                                         |
| 10    | Ardışıl devrelerin durum tablosu, durum diyagramı ve sonlu durum makineleri         |
| 11    | Flip-Flop’lar: D, T, SR, JK,flip-flopları, tutucular                                |
| 12    | Ardışıl devrelerin çözümlenmesi                                                     |
| 13    | Ardışıl devrelerin tasarımı                                                         |
| 14    | Saklayıcılar, sayıcılar, bellekler, programlanabilir ardışıl devreler               |
| 15    | Final                                                                               |

* Sinyaller ve Sistemler
** Ders Bilgisi
*** Dersin İçeriği

Temel konseptlere giriş; Sinyaller ve Sistemler; Doğrusal ve Zamanla Değişmeyen Sistemler;
Sürekli Zamanlı Sistemlerin Zaman Bölgesi Analizleri; Ayrık Zamanlı Sistemlerin Zaman Bölgesi Analizleri;
Sürekli Zamanlı Fourier Serisi; Ayrık Fourier Dönüşümü; Sürekli Zamanlı Fourier Dönüşümü;
Bazı Fonksiyonların Fourier Dönüşümleri; Örnekleme ve Yeniden-kurma; Laplace Dönüşümü; z-Dönüşümü.

*** Haftalık Konular ve İlgili Ön Hazırlık Çalışmaları

| Hafta | Konular                                                                                                                                                                                                                                                                                             |
|-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <c>   | <l>                                                                                                                                                                                                                                                                                                 |
| 1     | Sinyaller ve Sistemlere genel bakış / Sürekli zamanlı sinyaller / Ayrık zamanlı sinyaller / Sistemler / Sistem örnekleri / Temel sistem özellikleri / Sinüzoidler ve karmaşık sinüzoidler                                                                                                           |
| 2     | Spektrum gösterimi / Fourier Serisi analizi ve sentezi / Fourier Serisi’nin üç gösterimi / Zaman-Frekans spektrumu                                                                                                                                                                                  |
| 3     | Sürekli Fourier Dönüşümü / Fourier Dönüşümünün özellikleri / Belirli sinyallerin spektral içeriği                                                                                                                                                                                                   |
| 4     | Sürekli zaman sistemlerinin Fourier Analizi / Periyodik ve periyodik olmayan girişlere yanıt / Sürekli zaman filtreleri / Frekans cevabı / Fourier Dönüşümü özelliklerini kullanmaya yönelik örnekler                                                                                               |
| 5     | Sürekli zamanlı sinyallerin örneklenmesi / Örnekleme ve örtüşme kavramları / Örnekleme ve geri çatma kavramlarının spektrum yaklaşımı / Ayrıktan sürekliye dönüşüm / Örnekleme Teoremi                                                                                                              |
| 6     | Sürekli Zaman Sistem Analizi / Sürekli zamanlı evrişim / Sürekli Zaman transfer fonksiyonu ve frekans cevabı / Frekans cevabını görselleştirmek için sürekli zaman Bode diyagramları.                                                                                                               |
| 7     | Evrişim ve frekans cevabı ile ilgili örnekler                                                                                                                                                                                                                                                       |
| 8     | Sürekli zaman Laplace Dönüşümü / Laplace Dönüşümü özellikleri ve tablosu / Ters Laplace Dönüşümünün hesaplanması                                                                                                                                                                                    |
| 9     | Ara Sınav 1                                                                                                                                                                                                                                                                                         |
| 10    | Ayrık-Zamanlı Sistemler / Genel FIR Filtresi / FIR Filtrelerinin Uygulanması / Lineer Zamanla Değişmez (LZD) Sistemler / Evrişim ve LZD sistemler / Kademeli LZD sistemler                                                                                                                          |
| 11    | FIR sistemlerinin sinüzoidal yanıtları / Kararlı durum ve geçici yanıt / Frekans cevabının özellikleri / Frekans cevabının grafik temsili                                                                                                                                                           |
| 12    | z-Dönüşümü / z-Dönüşümü ve doğrusal sistemlerin tanımı / z-Dönüşümün özellikleri / z-uzayı ile frekans uzayı arasındaki ilişki                                                                                                                                                                      |
| 13    | Ara Sınav 2                                                                                                                                                                                                                                                                                         |
| 14    | Genel IIR Fark Denklemi / Zaman-uzayı cevabı / IIR Filtrenin sistem fonksiyonu / Kutuplar ve sıfırlar /IIR Filtresinin Frekans Tepkisi / Ters z-Dönüşümü ve bazı uygulamalar / Kararlı durum tepkisi ve kararlılık / İkinci dereceden filtreler / İkinci dereceden IIR filtrelerinin frekans cevabı |
| 15    | Final                                                                                                                                                                                                                                                                                               |

* İstatistiksel Veri Analizi
** Ders Bilgisi
*** Dersin İçeriği

Temel istatistiksel kavramlar, tanımlayıcı istatistik, şartlı olasılık, rasgele değişkenler,
tahmin-ayrık-sürekli olasılık modeller, birleşik ve örnek dağılımlar, hipotez testi, güven aralıkları,
karmaşıklık matrisi, mantıksal regresyon, doğrusal ve çoklu regresyon ve test teknikleri.

*** Haftalık Konular ve İlgili Ön Hazırlık Çalışmaları

| Hafta | Konular                                                                                                                                                                                                                                                                         |
|-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <c>   | <l>                                                                                                                                                                                                                                                                             |
| 1     | Giriş - Bilimsel Araştırmalar Bağlamında İstatistiksel Yöntemler. Örnekleme. Gözlemsel Çalışmalar ve Deneyler. Veri Keşfi ve Analiz. İstatiksel Çıkarım. R kullanarak hesaplama.                                                                                                |
| 2     | Veri Keşfi - Veri Görselleştirme ve Özet İstatistik. Değişken Türleri. Kategorik Değişkenleri Keşfetmek. Nümerik Değişkenleri Keşfetmek. Veri Önişleme.                                                                                                                         |
| 3     | İlişkileri Keşfetmek - Değişkenler Arasındaki İlişkileri Görselleştirme ve Özetleme. İki Sayısal Rastgele Değişken Arasındaki İlişkiler. Kategorik Değişkenler Arasındaki İlişkiler. Sayısal ve Kategorik Değişkenler Arasındaki İlişkiler.                                     |
| 4     | Olasılık - Belirsizlik Ölçütü Olarak Olasılık. Tümleyen, Birleşim ve Kesişim. Ayrık Etkinlikler. Şartlı Olasılıklar. Bağımsız Etkinlikler. Bayes Teoremi.                                                                                                                       |
| 5     | Rastgele Değişkenler ve Olasılık Dağılımları - Rassal Değişkenler. Olasılık Dağılımları. Kümülatif Dağılım İşlevi ve quantile.                                                                                                                                                  |
| 6     | Tahmin - Parametre Tahmini. Nokta Tahmini. Örnekleme dağılımı. Güvenilirlik Aralığı. Hata Marjı.                                                                                                                                                                                |
| 7     | Hipotez Testi - Popülasyon Ortalamasına İlişkin Hipotez Testleri. İstatistiksel Anlamlılık. t-testlerini kullanarak hipotez testi. Popülasyon Oranı için Hipotez Testi.                                                                                                         |
| 8     | İki Değişken Arasındaki İlişkinin İstatistiksel Çıkarımı - Bir Sayısal Değişken ile İkili Değişken Arasındaki İlişki. İki ikili Değişken Arasındaki İlişki Üzerinde Çıkarım. İki Nümerik Değişken Arasındaki Doğrusal İlişki ile İlgili Çıkarım.                                |
| 9     | Ara Sınav 1                                                                                                                                                                                                                                                                     |
| 10    | Varyans Analizi (ANOVA) - Giriş. ANOVA Varsayımları.                                                                                                                                                                                                                            |
| 11    | Kategorik Değişkenlerin Analizi - Bir Kategorik Değişken İçin Pearson'un χ2 Testi. Pearson'un χ2 Bağımsızlık Testi. Durum Tabloları.                                                                                                                                            |
| 12    | Regresyon Analizi - Tek İkili Açıklayıcı Değişkenli Doğrusal Regresyon Modelleri. Basit Doğrusal Regresyon Modellerini Kullanan İstatistiksel Çıkarım. Tek Sayısal Açıklayıcı Değişkenli Doğrusal Regresyon Modelleri. Model Varsayımları ve Teşhisi. Çoklu Doğrusal Regresyon. |
| 13    | Kümeleme - K-means Kümeleme. Hiyerarşik Kümeleme. Kümelemeden Önce Değişkenleri Standartlaştırma.                                                                                                                                                                               |
| 14    | Bayes Analizi - Giriş. Önceki ve Sonraki Olasılıklar. Bayes çıkarımı. Tahmin. Hipotez testi.                                                                                                                                                                                    |
| 15    | Final                                                                                                                                                                                                                                                                           |



